# Snowflake Research Summary

| Feature                                | Description                                                  | Common Use Cases                                             | Pros (Advantages) ✅                                          | Cons (Limitations) ❌                                         |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Zero-Copy Cloning**                  | Creates a nearly instantaneous copy of a database, schema, or table by duplicating its metadata, not the underlying data. The clone shares the original data micro-partitions. | 1. **Dev/Test Environments:**Quickly create isolated environments for development and testing.  2. **Data Backup:**Create instant backups before major data transformations.  3. **Data Sharing:**Provide a full copy of data to another team for analysis without data movement. | - **Speed:**Cloning is almost instant.  - **Cost-Effective:** No additional storage costs until data in the clone or original is modified.  - **Agility:**Accelerates development and data analysis workflows. | - **Storage Costs:** Changes made to the clone or source object will start to incur storage costs.  - **Complexity:** Understanding the metadata-only copy concept can be tricky initially. |
| **COPY INTO**                          | The primary command for **bulk loading** data into a Snowflake table from files located in an internal or external stage (e.g., AWS S3, Azure Blob). | 1. **ETL/ELT Pipelines:**Efficiently load large, transformed datasets.  2. **Initial Data Migration:** Bulk load historical data from legacy systems.  3. **Batch Loading:**Load daily or hourly data batches from external sources. | - **High Performance:**Optimized for loading large volumes of data quickly.  - **Versatility:**Supports various file formats (CSV, JSON, Parquet, etc.).  - **Transactional:**Loads data in an all-or-nothing manner to ensure integrity. | - **Inefficient for Small Inserts:** Not suitable for single-row or small, frequent insertions (use `INSERT`instead). <br> - **Staging Requirement:** Data files must first be placed in a Snowflake stage. |
| **Time Travel**                        | Allows you to query or restore data from any point within a defined retention period (1 to 90 days) without needing manual backups. | 1. **Data Recovery:**Restore tables or rows that were accidentally deleted or updated.  2. **Historical Analysis:** Analyze how data has changed over time.  3. **Auditing:**Examine the state of data at a specific historical point for compliance. | - **Instant Recovery:**Simplifies and speeds up data restoration.  - **Auditing:**Provides a clear history of data modifications.  - **Simplified Operations:**Reduces the need for traditional backup management. | - **Storage Cost:** Incurs costs for maintaining historical data.  - **Limited Retention:** Data is only available for the configured period (max 90 days).  - **Not for All Tables:** Only available for permanent tables, not transient or temporary ones. |
| **Streams & Tasks**                    | A combination of features to enable Change Data Capture (CDC) and automated data pipeline execution.  - **Streams:** Capture DML changes (inserts, updates, deletes) on a table.  - **Tasks:** Schedule and execute SQL statements automatically. | 1. **ETL/ELT Automation:** Use a stream to capture new data and a task to process and load it into a target table.  2. **Data Replication:** Keep tables in different schemas or databases synchronized.  3. **Triggering Alerts:** Monitor a table for certain conditions and trigger an alert or action. | - **Real-Time Processing:**Enables near real-time data pipelines.  - **Automation:**Automates recurring SQL jobs, reducing manual effort.  - **Simplified CDC:** Natively captures data changes without complex triggers. | - **Complexity:** Can add complexity to data workflows and dependency management.  - **Latency:** Processing is near real-time, not instantaneous.  - **Resource Consumption:** Tasks consume warehouse credits when running. |
| **Data Masking & Row Access Policies** | Security features to control data visibility.  - **Data Masking:** Dynamically redacts or hides sensitive data in columns based on user role.  - **Row Access Policies:** Filters which rows a user can see in query results. | 1. **Compliance:**Protect PII/PHI to meet GDPR, HIPAA, and other regulations.  2. **Role-Based Access:** Show full data to privileged users (e.g., HR) but masked data to analysts.  3. **Secure Data Sharing:** Share tables containing both sensitive and non-sensitive data securely. | - **Centralized Security:** Define security policies once and apply them to many tables.  - **Dynamic & Transparent:**Policies are applied automatically at query time.  - **Enhanced Governance:**Strengthens data security and access control. | - **Performance Overhead:** Can introduce a slight performance impact on queries.  - **Enterprise Feature:** Requires Snowflake Enterprise Edition or higher.  - **Policy Management:** Requires careful design and maintenance of policies. |
| **UDFs & Stored Procedures**           | Features for creating reusable code blocks.  - **UDF (User-Defined Function):** Returns a single value or a table. Used like a built-in function in SQL queries.  - **Stored Procedure:** Executes a block of procedural code (e.g., with loops, branching) and can perform actions without returning a value. | 1. **Encapsulate Logic:** Hide complex business calculations inside a UDF.  2. **Automate Tasks:**Use a stored procedure to perform multi-step administrative tasks.  3. **Dynamic SQL:**Build and execute SQL statements dynamically within a stored procedure. | - **Reusability:**Write code once and use it in many places.  - **Modularity:**Breaks down complex logic into manageable components.  - **Simplification:**Makes complex queries easier to write and read. | - **Debugging:** Can be more difficult to debug than standard SQL.  - **Performance:** Poorly written UDFs or procedures can negatively impact performance.  - **Language Support:** Requires knowledge of supported languages (SQL, Java, Python, etc.). |